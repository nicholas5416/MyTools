# 游戏外挂编程如何系统学习

> 作者：[无忧无求](https://www.zhihu.com/question/23382807/answer/57144206)

我也来简单回答一下题主。  
  
首先, 外挂是一门很大很注重实践的一门技术大类。  
  
在这个技术大类之下还分很多小类。  
  
一般来说分逆向,编写逻辑 这2方面  
  
所谓逆向，也就是分析游戏的客户端，寻找相关功能的函数  
  
而编写逻辑，如掉线重登，自动打怪，自动吃药 之类等等等。  
  
但是实际上, 写一个挂，远远不止上述的2方面  
  
比如说还要过游戏的保护，这个需要运用Window内核的知识。  
  
以前的大神写挂都是单独一人完成的，这个需要懂的内容非常非常多。  
  
我列举一下成为一个全能大神所需的知识：  
  
首先，汇编的基础知识必须过硬,有良好的逆向经验。了解常用的数据结构（因为游戏的背包或者怪物之类的多用二叉树或者数组, 连基本的数据结构都不懂……那玩个蛋）  
  
了解API，R3（Native API），R0（内核）,Socket。熟悉一门编程语言(只会汇编也可以)  
  
如果你能把上述的学精，就有成为大神（外挂类）的潜质。  
  
-------------------------写着写着突然不想写了,以后再补充吧--------------------------------------  
  
竟然有人评论……那我继续写了。

如果是对编译原理比较了解的基友,应该就知道。  
  
一个静态函数是一个固定的CALL,一个struct的结构内容都是用偏移可以算出来所有成员的。  
  
所以逆向游戏客户端,分析出游戏中的某些功能函数的地址，再加以分析出所传递的参数,模拟调用。这样一个简单的功能就完成了。  
  
当然,这中间还牵扯到其他不少的东西, 比如说必须熟悉结构,  
  
举个栗子：  
  
当你看到一个参数他的内存形式如下：  
  
0x12345678:11111110  
  
0x1234567C:11111110  
  
0x12345680:11111114

这样的玩意，就很快可以联想到这是一个数组，还是一个vector。  
  
这些除了要有逆向的功底以外，还需要有“逆向游戏的经验”, 因为游戏的参数都那德行,万变不离其宗。  
  
除此之外, 游戏现在都有防多开的干涉。  
  
在不谈驱动保护的前提下, 你需要熟悉Window的工作机制,特别是互斥的工作原理,当然,现在游戏保护不止是互斥判断多开,比如说进程路径重复，类名，窗口名，互斥，内存映射,判断文件是否存在等等之类的……所以你至少要把那本Window核心编程给看熟。  
  
这方面的书籍, 我也没有太多的介绍, 现在有不少人是熟悉逆向，而不会过多的编程的“外挂作者”。 他们都并非靠对编译原理的理解去逆向游戏数据,而且靠“经验”去逆向游戏数据。  
  
总的来说,我看他们都是在网上找教程看下,再加以练习，就能达到这个水准了。

那么接下来再讲讲编程这块。  
  
因为需要稳定不需要过多的人工量去看的挂机,所以你需要写得非常“智能”,简化操作流程,还要把角色的伤害跟玩家相提并论, 此过程听起来很简单, 操作起来非常麻烦。  
  
首先多线程你要懂吧？ 比如说你必须无时无刻都在判断人物Hp低于某个程度就得啃药了吧？总不能每写一句代码就写if判断一次血量吧？  
  
还有某些全局数组或者vector之类的多线程操作,比较基础的互斥啊，临界区之类的你要用吧？  
  
总而言之,多线程这块就是麻烦！这类书籍我也就不班门弄斧了,想必各种大神的推荐应该更有力。  
  
接下去还需要懂Native API。 就是俗称的R3. 亦是巨硬没公开的API， 需要用这层去隐藏自己的DLL，防止游戏的检测。 还有多开之类的，一般都在这层完成的。  
  
你需要懂一点PE文件格式,把大部分的Native API的运行方法,调用方式给弄懂。  
  
还需要懂Socket网络编程.  
  
因为 你需要怎么“验证”自己,达到给工作室收费的目的,  
  
还有你需要怎么“验证”自己，达到防止被别人破解的目的  
  
当然,牵扯到socket了,我是看了,会socket的，大部分都会数据库操作的。  
  
要嘛是MSSQL,要嘛是MySQL。 这个方便查询和管理。（这个数据库对写挂木有硬性要求）  
  
socket无非就是粘包之类的,超时之类的判断。 赶脚不需要学到很深。  
  
当然,如果你还要弄脱机挂,底层的TCP协议是必须会的。  
  
还有加密和解密算法得杠杠的,逆向功底也要杠杠的。

我想下,编程这块应该就剩下个脚本了吧？ 会一门脚本语言这个应该很easy。  
  
还有应该懂一点算法, 比如说A*, dijkstra,之类的。

剩下就是Window内核了,就是俗称的R0,驱动层。  
  
……  
  
就先写到这里了……以后想多了再补充。

  
  

------------------8.24号更新--------------------------------  
  
有兄台问： 为何要精通汇编……  
  
这……难道还有游戏的源码供你调试？  
  
在木有游戏的源码下，只能看汇编……

有兄台问：现在外挂的行情如何：  
  
我只能说, 没几年前那么好赚了， 几年前在DNF大火的时候，养了一大批中国的外挂作者和工作室。 但是现在的游戏，防得越来越严了。  
  
新人最难的就是入门， 而真正赚钱的东西，都被各家的前辈捂得严严实实的。  
  
哪怕你是一个编程高手，逆向高手。 当你真正写出一个挂的时候，会发现，玛德被封号了。 为何不稳定？ 5分钟掉一次线？ 为何总是跟不上工作室的需求, 不知道弄什么功能出来才是工作室所需的，而工作室本身就不是很懂技术，说的东西总是含糊其词的…… 恨不得直接可以刷软妹币到他们的口袋。

这个行业很讲经验, 对付封号的经验，跟工作室配合的经验，熟悉游戏的经验， 怎么才能用最短的时间，写出工作室最需要的功能。

顺便一提, 就是这些经验，都是需要时间的日积月累。 然而新人入门都倒在了这个门槛上，很少有人能够坚持个几年去不断摸索学习。  
  
当然现在也有很多写挂的教程视频，请允许我对这种视频说一句：然并卵！

真正赚到钱的作者，根本不会去在乎那点小钱，也不会拿这种共享的心态去分享这些经验，这些经验对于他们来说就是收入，他们公开了这些经验，很多人知道，就意味着很多游戏公司的反外挂部门也知道， 那就是打破自己的饭碗。

知乎很多大神，有很多反外挂的大神，也有很多写挂的大神都混在这里（所以我才匿名,免得被认出来）

很多人进这行1年都能赚百万，有人5年都赚不到10万。 总是有高有低，有起有落的。

就如同在国家严打黑客前，当年的刷钻盗号，入侵教程如春笋般在各种网站上公开叫卖, 肆意挥霍的年代， 很多大神就是从那个（相对于现在这个年代的环境已经是超级好了）年代成长起来，以前是年代也是“相对”比较单纯，现在学渗透，不如以前的学习环境好， 但是长江后浪推前浪，后浪死在沙滩上，依然有人在这种国家要严打的环境下 还是成长到媲美 上一代大神的境界。

最后给各位读者一句衷心的劝言：  
  
没有一颗沉得住寂寞的心，不要轻易进这个行业  
  
没有一颗2年都赚不到钱的觉悟，不要轻易进这个行业  
  
没有一颗坚强的心（偷摸拐骗在这个行业处处可见），不要轻易进这个行业

我也比较认同楼下的说法, ：  
  
技术的成长路线 全看个人，虽然这条路很偏，这门技术在“正统”的领域中，很少有用得上的。

最后总结一下这门技术, 是非常注重“实践”和“调试”，  
  
如果想增强一下对语言底层的理解，逻辑思维的增强，调试功底， 可以稍微浅入这个领域去学习一下。

特别是调试功底~！  
  
在木有源码，无法调试的情况下，甚至在不知道，出错是你的锅，还是游戏的锅。不知道为何运行一段时间崩溃后，疯狂查日志的寂寞。

这个行业 也确实是比较“浮躁”的一个行业，功利心很强， 大家都是向着利益看齐。因为利益而解散的写挂团队我也见过太多了。 可以这么说，写挂团队解散有60%是赚不到钱，35%是利益纷争，5%是其他原因。

---------先写到这里,虽然木有大神在行业混了8年的经验，也曾呆过这个行业一段时间，比较了解。 也很乐意分享各种见闻（经验分享我就不说了：毕竟这是灰色产业，明目张胆的说，会坑爹的。）---------------------------------

  
  

-----------2016.8.24-----------------------------------------------------  
  
嘿嘿， 好长时间没来更新了， 发现挺多赞的。 那就再更一发。  
  
老夫来说一下， 如果要完成一个“完整的工作室内存外挂”， 需要什么功能， 需要哪些技术。

首先：老夫只拿我自己做过的例子来举例， 不代表其他人的做法也是一样  
  
第一步： 写一个控制台。 我是用C#来写（MFC太烂了， 又长又臭。）， 方便工作室操作， 一般是存放帐号，还有操作一些配置文件（比如说设置低于%? 就吃药, 设置了收货【邮件或者交易】角色名之类等等诸如此类）。 为了防止别人认出来， 就不丢图了。 老夫找一张类似的图片

![](https://pic2.zhimg.com/f88277c198922a128a1cdfcff3bed4ad_b.png)

  
  

基本就做这个玩意。 大部分都是读取配置文件， 做一些界面交互的功能。 写好List。 和一些界面操作之类的。  
  
基本就是dataGridview操作， StreamReader, StreamWriter, 各种拖拉控件。 完事。

  
  

第二步：  
  
然后老夫会用cpp写一个DLL。 用来跟C#的界面交互。 利用内存共享来和游戏的DLL交互信息.  
  
基本这个就用到内存共享, CreateFileMapping, MapViewOfFile, OpenProcess, 诸如此类。 然后基本就是各种判断， 比如说掉线呐， 超时呐， 状态呐。 还有对在线帐号做各种判断操作， 比如说刷完 的角色要保存日志， 该删的删， 该留的留。 还要做登录初始化处理之类的。

第三步：  
  
写注入（基本都有现成的, 为了流程规范！ 还是单独列出来好了。 OOP思想已经祸害了老夫了）  
  
一般常用的注入很多， 比如说APC注入，输入法注入， DLL劫持。 OEP改入口。 远线程注入。 无模块注入（一般是申请一块内存， 然后把整个DLL复制过去。 修复导入表，重定位后，加载dllmain）， 还有驱动级的一大堆就不一一细说了。 注入方法五花八门，不管是哪种方法， 只要有效， 能防止游戏检测到，又可以用。 那就是一个成功的注入。

第四步：  
  
逆向游戏功能（其实这个才是第二步，注入是第一步）  
  
这里也分2种， 一种是先找遍历， 一种是先找发包  
  
//  
  
找游戏的明文发包， 这个可以大概说一下， 因为一般来说， 建立tcp连接， 都是需要connect, 然后send 或者 recv之类的。  
  
但是一般来说, 基本都是send都是经过单次或者多次加密后的密文封包, 所以并没有太大意思， 有些甚至是搞了多线程， 一个线程检查一个全局队列之类的然后send， 另一个线程负责push。 比如说基三就是这样干的！  
  
当然往上回溯之类的现在已经不怎么好用了。 这里面的篇幅太长太长了， 就不一一细说了， 因为里面还有很多小技巧的东西， 很多关于经验， 感觉之类的事。  
  
//  
  
遍历一般是指， 周围怪物， Npc， 技能， 背包， UI之类的。 从林林种种的数据结构中， 找到自己想要的数据。  
  
比如说怪物是用树状结构保存的， 但是每一个CMonster 都是一个超级大的结构。 他里面还包含了很多类，结构， 也可能继承了N个类， 也有N个指针，N个虚函数。  
  
很多我们都是不需要的， 所以需要一一细分， 比如说， 只要怪物HP,MP， 角度， 坐标，之类的。 像怪物的形状， 外形， 颜色之类的，我们根本不care！  
  
//  
  
然后就可以和明文发包结合了。  
  
举个栗子， 使用技能函数  
  
无法就是  
  
static UseSkill(dwSkillId, dwTargetId)  
  
{  
  
send(............)  
  
}  
  
所以你找到你明文发包的CALL。 那么你只需要在CALL头部下一个断点即可。  
  
基本内容就是只要SkillId和TargetId,  
  
比如说  
  
卖， 也一般就只有NpcId, ItemId, Count之类的。 游戏不一样， 可能做法不一样。

从这一步， 可以实现相当多的功能， 比如说自身的HP<? 就使用物品。  
  
可以实现自动打怪，捡物， 做任务之类的………………  
  
这一步其实需要的功能很复杂， 但是技术含量我认为并不高。 时间做久了， 就是写业务逻辑的事。

第五步：  
  
就应该来到脚本这块了。 如果是用lua写脚本的话。 那基本就是封装几个函数的事。 比如说交任务， 接任务， Move， Npc对话之类的。 反正大部分游戏不都那个尿性嘛？整天跑来跑去， 跟几个Npc对对话， 虐虐小怪， 跟Npc美女谈笑风生。  
  
这块就是体力活了。

第六步：  
  
把控制台, 控制台DLL, 游戏DLL结合起来。　比如说血量控制呐，　超时判断呐，　怪物过滤表之类的要与控制台交互起来。

第七步：  
  
socket, 要给工作室写收费系统。 这一步工作量也不少。 前面几步是跟游戏斗智斗力， 这一步是跟破解者斗智斗力， 比如说有很多阴险的检测. 什么删系统， 格式化之类的。

第八步：  
  
基本这一步就可以到封号的步骤了， 以前游戏封号五花八门, 也有很多规则可循的。  
  
比如说某个区域就检测加速， 某个时间段就检测一次。 检测到就晾个几天再把你封号。 还有CRC校验代码段， 上传DLL， 按键检测， API检测………………  
  
我说几个例子， 某游戏， 就在检测你模拟鼠标， 比如说正常人的鼠标， 是有轨迹的移动过去的。 他就给你检测你的鼠标是否“瞬移”出现在某处， 还有键盘的按下和弹起时间， 太快了要遭殃！（这种都有权值的， 大意就是分数。 超过及格线， 基本就晾个几天就必封了！）  
  
比如说还有堆栈回溯， 查看调用CALL是否在本模块中………………  
  
据说TX跟暴雪 学了一个新招， 做一个Loader加载器。 然后随机从服务器下载一段shellcode。 然后运行这段代码， 把结果返回给服务器。 本地毫无痕迹！ 而且下载回来的代码全部是vm混淆过的。  
  
咳咳， 里面还有各种奇招， 就不一一阐述了！

回头一想, 也发现漏了很多步骤， 比如说TX的就有TP保护。 盛大网易的有HS和NP保护。 所以还需要驱动层说。 比如说TP是DebugPort清0之类的。 NP老版本可以解密配置文件剥离。 还有重载内核， 用VT， 自己重写异常处理之类的一大堆手段可以过保护。

也有游戏多开没说， 还有隐藏自身这块也没说……  
  
发现写了N多了。 就先说到这里了。 有空下次再更新！  
  
赞多了再更！

----------2016.4.18--------------------------------------------------------  
  
长夜漫漫， 无心睡眠。 那就来更一发吧！  
  
这次直接上教程和代码（用TX的某游戏来演示， 只进行技术研究, 禁止用于非法用途！ ）

![](https://pic2.zhimg.com/5b97ad17aa9fcfa0e08fc95003825455_b.png)

祭出CE！ 开始从人物HP下手

![](https://pic1.zhimg.com/534e304c61519179e9e24270974a07b8_b.png)

  
  

开始找小怪攻击自己来掉血

![](https://pic3.zhimg.com/2f64f0db7b9d648335477ed3f970f94e_b.png)

找到了！

索引第0,1,3个是当前HP 2,4是MAXHP

接下来打开OD! (怎么附加进程这里略过……这个又可以说一个一本书那么厚的文章的如何对抗TP反调试)

![](https://pic3.zhimg.com/7acc812cf5a82c9f87104bcaab918b62_b.png)

0x2E70=11888(因为已经回满血了)

![](https://pic3.zhimg.com/eb754b5ad3d0d78927b5c97a79c0476e_b.png)

下一个硬件访问断点!

  
  

  
  

![](https://pic4.zhimg.com/d7d78c37ed4cba918d93e9bcc7a7d997_b.png)

  
  

```ca65
004705E1    8B87 C0000000   MOV EAX,DWORD PTR DS:[EDI+C0]

```

从这句代码可以看出, 这个角色当前HP 是 EDI + 0xC0.

那么你可以猜EDI就是当前人物角色指针.

![](https://pic3.zhimg.com/e16ed4f31203be5a950037a511374f02_b.png)

那么我们继续回溯这个指针是怎么来的!

![](https://pic4.zhimg.com/f10aba3bd7bc8130f2d74d32c3d96fdb_b.png)

```ca65
00470588    8BB8 80000000   MOV EDI,DWORD PTR DS:[EAX+80]

```

![](https://pic2.zhimg.com/5d22df156ed81f513ccd3c01770f2fa9_b.png)

继续往上翻。 就可以得出人物血量= \[\[\[11B0A9C\]+34\]+80\]+0C0

![](https://pic2.zhimg.com/97a3b6b8eee64e89ae0c219f360fe665_b.png)

这里11B0A9C 是一个全局静态类

如果对C++这块稍微有点了解的就知道了。 这种情况不过是类里面有类/结构 变量/指针

比如说

```cpp
class CBns2
{
...........
}

struct strcut1
{
........
}
class CBns1
{
.......
.......
CBns2 CBns2_;
strcut1 strcut1_;
CBns2* pCBns2_;
strcut1* pstrcut1_;
}

```

  
  

  
  

当然也不一定是这样的。 推测罢了。

// 注意, 这里的11B0A9C 是静态指针， 一般来说是不会变的。 如果会变的。 他有可能是属于DLL的全局指针， 因为win7有地址随机。 所以不能这样直接写。暂时先说这个情况

// 把DLL注入到游戏的情况下， 否则只能用OpenProcess + ReadProcMemory的方式读取

然后就可以写代码来实时获取人物血量了!

```cpp
DWORD ReadDWORD(_In_ DWORD dwAddr)
{
	DWORD dwValue = 0;
	if (!IsBadCodePtr(FARPROC(dwAddr)))
		dwValue = *(DWORD*)dwAddr;

	return dwValue;
}
DWORD WINAPI _WorkThread(LPVOID lpParm)
{
	while (true)
	{
		DWORD dwHp = ReadDWORD(ReadDWORD(ReadDWORD(ReadDWORD(0x11B0A9C) + 0x34) + 0x80) + 0xC0);
		::Sleep(100);
	}
	return 0;
}

```

  
  

这里就可以获取到人物HP了! MAXHP略过, 方法同上!  
  
接下去就可以继续逆向游戏功能  
  
比如说要做一个吃药的功能。 当HP < %50的时候, 就自动吃药. 伪代码如下  
  
while(true)  
  
{  
  
::Sleep(100);  
  
if(GetPercentHp() < 50 && ExistItem(回血道具) && GetItemCD(回血道具) == 0)  
  
UseItem(回血道具)  
  
}

……不知不觉已经凌晨2点了。 下次有机会再把上面的逆向和代码写完。  
  
记得点赞!

////////2016.6.14///////////////////////////////////////////////////////////////////////////////

继续更！

接下来做找明文发包CALL。 一般游戏处理是 明文打包->加密包->send

过程略……发包就在这里

![](https://pic3.zhimg.com/1fa2d69e5677e1caf6daf8d9807d46d2_b.png)

  
  

啃一瓶药.

下断点!

![](https://pic4.zhimg.com/772cbbe51149d62cfbfb31ae6b2d0def_b.png)

从调用堆栈可以看到调用的函数地址

![](https://pic3.zhimg.com/6f727e48a54c5622d3d5515e248de2c2_b.png)

然后一个一个分析参数。

首先逆向游戏是需要先对游戏的数据结构有一定了解才能模拟调用。

比如说这里的

PUSH 30

CALL 00CDF02E

就是申请 0x30大小的内存大小嘛

![](https://pic4.zhimg.com/a95a56689aa1b9026fbfc1597e0d8077_b.png)

然后从这一层可以看到代码大概如下， 只要把0x30的参数按原来的形式填进去, 就能send

那个10002从其他地方分析(略)可以得出， 1是指背包位置， 最后一个2是指类型。 2是指背包.  
  
所以如果背包第二个物品就是20002, 背包第三个物品就是30002.  
  
EAX >> 0x10就是获取背包位置  
  
申请的内存是MOV ESI,EAX.  
  
所以MOV WORD PTR DS:\[ESI+10\],AX  
  
就是  
  
*(WORD*)(ESI + 0x10) = 背包位置;

然后接下去看看别的参数

![](https://pic3.zhimg.com/422252989afe5c5f8646e0e75e62c416_b.png)

先将申请的内存清0

![](https://pic2.zhimg.com/00bed15fbe3fc35c5abf36c0c27c5221_b.png)

可以看出来这个0x30大小的数组内容是这些.  
  
基本上就是0x10是填物品位置。  
  
然后0x28和0x2C填0xFFFFFFFF  
  
然后干货就是0x18,0x1C,0x20了

然后接下去继续返回上一层继续找EBX的来源会发现他其实就是\[\[\[11F57AC\]+34\]+80\]  
  
所以  
  
*(DWORD*)(ESI + 0x18) = \[\[\[\[11F57AC\]+34\]+80\]+8\]  
  
*(DWORD*)(ESI + 0x1C) = \[\[\[\[11F57AC\]+34\]+80\]+C\]

至于0x29嘛, 刚刚准备写的时候发现

![](https://pic2.zhimg.com/bdf2925d9441bba95be9cf50d4e97f51_b.png)

算了。 就写到这里啦。

感觉下次得上欧美服或者韩服去才行。 国服真是越来越难调试了。

// by 7.29  
  
想要我私信的自己先想好问什么问题好嘛？  
  
前面一大堆人我都私信过了, 结果一大堆都是连问问题都问不清的人, 剩下的一堆就是无视了我的私信。  
  
最后还有1个想让我教他的，我也教了差不多2个星期。 结果两天打渔三天晒网.  
  
劝各位一句：只要是学编程相关的， 自认不是天才的情况下， 还是老老实实每天敲8个小时代码(看书), 不然你这样学到30岁都不知道能不能学有所成。

// by 8.13  
  
我挺可以分享行业见闻的, 但是不代表也可以分享我个人的隐私, 跟其他人交流过经常都问你赚了多少钱, 搞了哪些游戏之类的……等等诸如此类的问题, 我拒绝回答敏感性的问题!

  
  

// by 8.17

论如何修改魔兽3的攻击为混乱攻击, 护甲是神圣护甲

![](https://pic4.zhimg.com/f556b3eb636666586676fc74abbc70e3_b.png)

改成

![](https://pic4.zhimg.com/8d8fba476f3271a778e79d78f977166f_b.png)

  
  

  
  

0x1:

在做之前要想好'切入点', 就是游戏在哪会调用到攻击类型这个玩意呢?

比如说可以在使用技能（包括普通攻击）之后, 造成伤害之前是需要获取的。

但是也不好入手, 因为使用技能的判断太多了, 不好区分。

又或者说。 可以这样!

![](https://pic3.zhimg.com/7bfc2cb3566a3ec7cf5fc8e643b7d1da_b.png)

把鼠标放到攻击上面, 他'应该'会获取当前的攻击类型，然后转换成Text -> Update 到界面  
  
, 好, 接下去就试试这招!

………………  
  
但是在获取这个攻击类型之前, 还要获取一个东西， 就是获取该英雄的Object.  
  
如何在茫茫人海里面把该英雄找出来, 因为每一个英雄都有自己的攻击种类, 所以第一件事就是要找到自身的Object指针!

从人物HP入手, 买点装备丢装备来达到人物HP不断变化的目的. 最终找到了

![](https://pic3.zhimg.com/397e13b912ba4e3e10dbd544de1d83de_b.png)

一个是HP一个是MAXHP  
  
随便掉点血就知道第一个是HP, 第二个是MAXHP.  
  
附加OD, 在HP下访问断点

![](https://pic2.zhimg.com/4f6b71659b8b4d8f297fc34a5130a7f1_b.png)

![](https://pic3.zhimg.com/46740b9c23e698c4ed629387310bc37e_b.png)

  
  

看上一层,

```asy
023C8C1B  |.  8BBE 48020000 mov     edi, dword ptr [esi+248]         ;  HP

```

ESI就是人物指针. 往上回溯, 看下ESI是怎么传递的

一直翻啊翻, 翻到函数头了

![](https://pic1.zhimg.com/69ee98ac198f1ea80a4c39c4411aed68_b.png)

ESI=ECX. 一般ECX或者ESI传递的， 都是this指针, 就是类指针.

比如说 Class::AAA() 里面默认有一个参数传递this指针. 汇编自动生成, 但是代码省略.

![](https://pic3.zhimg.com/fd26526828453b16727a23088b8485fa_b.png)

同理, 顺便做个记号, 因为你总不可能记0x????? 老夫记忆力不行.

![](https://pic4.zhimg.com/68a2a78a40e6e3ad2b194e9c23cce62f_b.png)

继续回溯!

![](https://pic4.zhimg.com/c18ac5a153362a456500626ed454dca7_b.png)

  
  

函数头

![](https://pic2.zhimg.com/304ce33fcf15dd01b5dec3ec9cc9f099_b.png)

继续回溯

![](https://pic1.zhimg.com/1281ba4891782f93c98220792f7bfd4c_b.png)

  
  

发现了这样！ 很明显就是一个递归嘛!

先不管这个递归, 直接先找到上一层, 因为如果你一直卡在这个递归里面, 万一你上一层也是N个递归或者说是一条死路呢？ 所以你得先寻找到根源, 再做详细分析!

继续函数头部下断点， 那么你会发现

![](https://pic2.zhimg.com/e2068ba7897b83c7c7b2bdaf7e2df805_b.png)

  
  

他的\[ESP\]=266E02B

![](https://pic2.zhimg.com/86e925713794f04d0621b6bb1e7c5455_b.png)

  
  

也就是这里. 所以要过滤这个!使用条件断点!

\[ESP\]!=266E02B

![](https://pic1.zhimg.com/9218577df273bc417d71d977019568a8_b.png)

  
  

![](https://pic4.zhimg.com/93be7dab7c174b7886676b5e1cc3946b_b.png)

总算找到Base了.

那么我们再来分析这个递归

![](https://pic3.zhimg.com/1882a5a257358a346c2037a47363cd8a_b.png)

  
  

好了。然后就可以动手了写代码了.

首先因为这个RootBase是在DLL里面的， 因为DLL的加载地址不同, 所以解析出的Base也不同， 这个需要知道PE文件的如何计算偏移的。

我就直接粗暴一点, 暴力搜索内存

![](https://pic3.zhimg.com/843b49b0939078c509c92c166ab34952_b.png)

![](https://pic4.zhimg.com/6a6e3e2ede5294c127fa22c8aabdafdb_b.png)

![](https://pic1.zhimg.com/b9567208319d7384324635554d5c4d70_b.png)

![](https://pic1.zhimg.com/a30533b6b6999ece561941c8a3038ecc_b.png)

MFC做个注入DLL…… 不要问我为嘛用MFC，因为它是VS自带的，方便立马用。反正关了灯都一样.

![](https://pic2.zhimg.com/9f95ee250e8336f3dc848172589ef2e1_b.png)

  
  

  
  

![](https://pic2.zhimg.com/edf87de1aa13b323c3a995b5620200dd_b.png)

随便写一个。 不要太讲究了。

编译！ 注入！ 测试！ 结果如下:

![](https://pic2.zhimg.com/afb6265272b08f90b6f7c0520aa2f5dd_b.png)

好啦。然后发现了辣么多个Base, 然后找名字!

  
  

从名字入手. 这个英雄叫'虚入梦'. 顺便这个游戏是UTF-8编码（略过如何求证的）.

所以这个英雄名称对应的编码是=E8999AE585A5E6A2A6

![](https://pic1.zhimg.com/fc7ec3704677db8f9d39ad4446ae4e28_b.png)

打开CE, 搜一下

![](https://pic1.zhimg.com/d4dff0a32b1e0e320227411eafc7121c_b.png)

务必要记住把 扫'只读'内存勾上

然后直接一个一个修改这个Text, 看下哪个是对应的名称. 比如说

![](https://pic1.zhimg.com/72f7aa6ad384d9adf29a1d24366e22a4_b.png)

手动修改一个

![](https://pic4.zhimg.com/c42ce206a4acc309490291d4593b7a0b_b.png)

![](https://pic1.zhimg.com/eedc8336b8c788a09cbd5a7bbfaba7d0_b.png)

运气好, 第一个就是。  
  
如果没变化, 那就一个一个往下改。 记得如果不是的话， 要改回去. 再改下一个。  
  
也可以用二分"修改"(查找)法, 直接一次性改一半. 如果不存在的话， 那肯定在另一半。时间复杂度O()=O(logn) 必须学以致用!!!

接下来就是开启OD, 附加游戏.

![](https://pic2.zhimg.com/862b689f27c3d0e2398216a32ede9459_b.png)

下一个访问断点.

![](https://pic3.zhimg.com/9401384ff2a17ee0539390b1ef91b896_b.png)

断下来了, 就是一个字符串循环复制, 返回到上一层CALL

![](https://pic3.zhimg.com/14609f4e290536fd04b7de658af7ef3e_b.png)

eax就是人物对象指针. edi就是一个缓冲区, 把人物指针的Name复制到缓冲区.

![](https://pic4.zhimg.com/362e60666ad2be61d4078d61af27aff3_b.png)

继续回溯

![](https://pic4.zhimg.com/1df162ddac6647d73abce7652a6bb00b_b.png)

这个CALL就可以用了。

```asy
PUSH 0x200
PUSH Buffer
MOV ECX, pObjectPointer
CALL 235F640

```

  
  

然而我在观察地址的时候, 就观察出来

![](https://pic3.zhimg.com/20a94d93d5035c754e8420780226f8ba_b.png)

  
  

因为他们2个地址是一毛一样的!

![](https://pic4.zhimg.com/5dd7109828a7813beaaceea9c75a5383_b.png)

ECX=\[ESI+238\]  
  
0DDF3CC4=\[14C90088+238\]

![](https://pic2.zhimg.com/33b1a3785ceadcb3b5e81b66912cf579_b.png)

其实往上跟也有可能可以关联起来， 但是我懒得继续回溯了……

![](https://pic2.zhimg.com/afd08d11549cc7dc432265a2f89cb851_b.png)

所以……

![](https://pic3.zhimg.com/5bb5279787f76ca71783990a2127a1da_b.png)

  
  

![](https://pic2.zhimg.com/987ba2c5c9d8d63439f123e786a14159_b.png)

  
  

![](https://pic3.zhimg.com/3d62886b2201f9dfaf213099d1cfa41e_b.png)

发现了有些地址可能是其他分类的吧？

分类判断懒得写了。 干脆

![](https://pic4.zhimg.com/2daa296d0b01376d164a06fadeb6b7cf_b.png)

  
  

![](https://pic2.zhimg.com/62f088a5daca02c39795e5ad64db92a5_b.png)

结果就是

![](https://pic2.zhimg.com/b915e2827970bd1ffcf48e1550f4854d_b.png)

好啦。 至少有一个是对的.  
  
因为刚才游戏不小心被我弄崩了。我就顺便重开而且换了个游戏.  
  
暂时目的达到了. 获取到当前角色. （遍历所有英雄小兵之类的暂时没这个需求,不做）

下一步就是修改攻击种类:

![](https://pic4.zhimg.com/b4f6480d2b5b55e45f299d440f178923_b.png)

按照刚才的步骤， 搜索显示的Text

![](https://pic1.zhimg.com/177cd69cd55a90869933e07a98b9173c_b.png)

  
  

2分搜索大法好， 3次即可到达。

下访问断点

![](https://pic2.zhimg.com/1c636920a108cd89e8ceb913e9630e65_b.png)

惯例的字符串复制操作， 返回到上一个函数!

  
  

![](https://pic2.zhimg.com/60ca3f8d8716a2c16d396f8887580a75_b.png)

  
  

EAX就是Text,

![](https://pic4.zhimg.com/128c6e8b61bc01e7b4d289ebcfe286af_b.png)

上面的MOV EAX, \[ESP+14\]. 就是从上一个函数传递过来的参数. 返回去看好一下.

上一层CALL看参数

![](https://pic4.zhimg.com/22f933ffa35e7906ddb9c6aea623edcf_b.png)

第一个参数

  
  

第二个参数

![](https://pic1.zhimg.com/3717582d6982fae35e0c7507db5ed454_b.png)

就是上上张图， 就懒得复制了

第三个参数

![](https://pic4.zhimg.com/563aa16955f206da8d9b5e5f51ac9e8f_b.png)

![](https://pic3.zhimg.com/b7e6b24b70137b9885e33597e22059c2_b.png)

就是这个玩意。 那么我们要找的是种类。 也就是第二个参数=\[ESP+0BC\]  
  
然后往上分析……过程略， 多断点几次的事， 我就不废话了。

然后往上慢慢下断看参数, 直到……

![](https://pic2.zhimg.com/1afec4883d71b44482ac1c30c17a8bf9_b.png)

  
  

![](https://pic1.zhimg.com/00696c82209057611298edc41b96e8e8_b.png)

mov edx, dword ptr \[esp+10\]  
  
mov ecx, dword ptr \[edx+2ADD3B0\]

![](https://pic3.zhimg.com/eba612405eecc7b1abca41cefe4314f2_b.png)

接下去就找\[ESP+34\]

![](https://pic1.zhimg.com/db2b89852b2de63b1889d1d7e2282910_b.png)

既然这样， 那么我们试试.

首先

![](https://pic2.zhimg.com/a6b9a79c1253af7e8057ef98edf798b9_b.png)

  
  

所以 \[0F923CC4\] + 1E8 = EDI

EAX = 攻击种类 = \[EDI + 0 * 4 + 0xF4\]. (已经探明EBX=0)

所以……

![](https://pic1.zhimg.com/587fff5c99ac6b1dba5e543d15263d50_b.png)

  
  

我们换一个有混乱攻击的号就知道。 混乱攻击的时候。 这个值是=5的。

所以我们改成5试试。

![](https://pic3.zhimg.com/41b71650bfd81153fee5108c4ed0d8de_b.png)

嘿嘿！

然后是不是有效。 最上面的那2张图有数值测试！

顺便…… 肯定是联网无效的， 因为有数值校验的。可以单机爽一下！

而且……哪怕你用各种作弊图， 暂时老夫还没发现哪个可以改攻击类型！

神圣护甲同理， 我就多此一举了。

还有几张图顺便贴了

![](https://pic4.zhimg.com/23e358135456651434270d96d798ab3b_b.png)

![](https://pic1.zhimg.com/4396f5523fb60ffb7ca984e6a25d6028_b.png)

  
  

这篇文章到这里就结束了。 以后在这篇文章也不会更新技术类的话题了。  
  
顺便！  
  
不知哪位英语比较好？ 最近学英语陷入死循环, 各种不爽背单词, 但是不背也不行。 有没有能拯救我……必有酬谢!

很多人都问怎么学, 其实嘛

[『求助问答』](//link.zhihu.com/?target=http%3A//bbs.pediy.com/forumdisplay.php%3Ff%3D20)

![](https://pic3.zhimg.com/44e74fcc4f5230c2fa970d96deaf086e_b.png)

我并非推荐你们去参加培训， 而是这里有课程目录。  
  
按照这个目录去学就好了。  
  
例如:[游戏安全工程师培训介绍-WebMaster-15PB信息安全教育](//link.zhihu.com/?target=http%3A//www.15pb.com/portal.php%3Fmod%3Dview%26aid%3D10)

老夫的git项目,无聊的时候写的LOL刷金币。 可以参考一下。  
  
强调一下： 只做技术交流。 不要瞎搞!  
  
[GitHub - VideoCardGay/LOL_China](//link.zhihu.com/?target=https%3A//github.com/VideoCardGay/LOL_China)

  
  

其实学习这玩意的路线，强烈建议有一定的编程基础，如果从0开始的话， 路只能 歪着走。

举个例子，在业内 有个称呼叫“_**数据手**_”, 也就是只会逆向游戏的数据， 但是对于一些编程知识一窍不通， 就说简单的注入, 脚本交互，内存管理, 线程操作， 更别提外挂是一个很大的工程(我是指能刷钱，能做主线，能打副本，能做socket网络验证)。

我还记得以前在贴吧开过一个科普贴，谈到DNF所有的“**变态功能**”(指秒杀，倍攻等)都是利用了**漏洞的原理**，根本是服务器和客户端计算校验不严，或者没办法把所有伤害运算放在Server上才让你**有机可乘**, 但是就有“**数据手**”来跟我扯一些就基址+偏移 改一下就好了， 逆向一下改某段代码就好了(**连Hook这样的词都说不出来**), 茴字的一种写法都说不上来。

学习要是带有目的性的， 要是业余爱好学习一下，不打算深造， 这样歪着学习法并没有什么不妥。 并不是说所有人都要往着专业的范畴去学习， 就好像我想学习一下摄像和后期来装一波而已， 需要我从0开始学习PS，各种数码基本知识，光照的各种应用等等等吗？ 你又不是想当摄影师， 搞那么多花里胡哨的。

  
  

  
  

给各位想自学的人一点学习方向的建议。  
  
一般分2种, 一种是为了编程而学外挂， 一种是为了学外挂而编程。  
  
第一种就是以编程为主, 对外挂技术了解一下。 这里就不谈了, 正统道路的学习方法多得是。 我就不一一举例了。  
  
第二种方法， 我以0编程基础来举例。  
  
1：要熟悉C/C++语法, 可以做一些像模像样的小玩意, 比如说控制台下的XX管理系统, 读写文件, 什么银行存取金币系统之类这样的小玩意。 这部分后面就要应用在你的外挂控制台上  
  
如:[知乎专栏](https://zhuanlan.zhihu.com/p/24427205)  
  
2：学习完上面的，我个人建议开始学习socket, 功能大概就要激活CDK，校验CDK的时间, 用长连接。 大概就是生成CDK, 把CDK保存到Server, 然后Client激活CDK要去Server校验, 并且用心跳来保持连接。  
  
这一步后面要应用到 防破解, 收费系统, 还有一些比如说组队, 交易, 邮寄都可以丢到Server上完成， 比如说不同电脑下, 如何让他们同一个大区同一个地图下如何分配组队和交易, 而且还能进一步锻炼你的编程能力。 建议要用非阻塞的异步socket。(用HTTP来做验证的可以忽略这一步)  
  
3: 这个时候可以做点有意思的, 比如说先学会用模拟按键+识图 去做某个游戏的登录。就用LOL来举例子, 可以做LOL的客户端登录。 用模拟按键+鼠标操作, 然后用识图来判断当前在哪个步骤了。 图片识别可以用OpenCv库[Template Matching](//link.zhihu.com/?target=http%3A//docs.opencv.org/2.4/doc/tutorials/imgproc/histograms/template_matching/template_matching.html),然后如果出现验证码, 可以用网上那种打码系统,QQ游戏的验证码挺便宜的, 最多几分钱一次。  
  
如:[VideoCardGuy/AutoLoginByBnsChina](//link.zhihu.com/?target=https%3A//github.com/VideoCardGuy/AutoLoginByBnsChina)  
  
4: 这个时候你可以写一个控制台(Console模式), 保存帐号, 读取帐号, 开始登录。 如何判断到游戏登录完毕, 就登录下一个帐号, 保存登录失败(如密码错误)的日志, 操作完毕的日志。 如何再下一次启动的时候忽略已经成功的帐号。 中间的种种操作, 自己做一遍就知道了。  
  
如:[VideoCardGuy/AutoLoginByBnsChina](//link.zhihu.com/?target=https%3A//github.com/VideoCardGuy/AutoLoginByBnsChina)  
  
5: 这个时候建议把Console模式的控制台改成UI, UI可以用C#来做，也可以用MFC/QT来做, 用哪个语言来做无所谓, 学习一下多线程的操作, 如何刷新数据到UI, 如何从Server查询CDK返回到控制台, 比如说剩余时间对吧.  
  
6:这个时候就开始学习简单的汇编指令, 学习如何使用调试器, 怎么去逆向游戏的人物属性， 把基本的HP,MP,攻击力之类的逆向出来， 然后显示到控制台， 这里需要比较多的API知识, 比如如何注入DLL到游戏, 比如运用指针读取游戏的数据. 这一步做完你已经可以自己写一个UI注入到游戏里面， 显示出人物各种属性,周围怪物,Npc。 你也需要一些基本的数据结构知识,比如链表,二叉树,数组,std::vector,std::string在汇编的表现形式。  
  
7:可以逆向游戏的功能, 找到游戏的明文组包函数, 然后下断后就能断下绝大部分游戏的功能, 然后想办法模拟调用, 你就可以做到吃药, 释放技能,交接任务。 这一步我就不多说了,反正完成了几乎是搞完了。  
  
8: 把所有功能和UI控制台和Server端关联起来。 就是一个完整版的挂了。 下面就是一步一步添加更多的功能了,要考虑用脚本去写主线了,要考虑框架的问题了,要学习如何反反调试,如何多开,防检测,过游戏保护,做资源优化,写导航寻路等等……当你都学完之后,那么恭喜你,你已经成功获得"外挂全能大神"的称号了。
